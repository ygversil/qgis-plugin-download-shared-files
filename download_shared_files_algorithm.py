"""
/***************************************************************************
 DownloadSharedFiles
                                 A QGIS plugin
 This plugin provides a processing algorithm to download files hosted on one or
 multiple web repositories.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-10-28
        copyright            : (C) 2021 by Yann Voté
        email                : ygversil@lilo.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Yann Voté'
__date__ = '2021-10-28'
__copyright__ = '(C) 2021 by Yann Voté'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'


from collections import namedtuple
from datetime import datetime
from urllib.parse import urljoin
from urllib.request import urlopen
import re
import pathlib

from PyQt5.QtGui import QIcon
from processing import run as run_alg
from processing.algs.qgis.QgisAlgorithm import QgisAlgorithm
from qgis.core import (QgsApplication,
                       QgsProcessingException,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFileDestination)
from yaml import SafeLoader, load as load_yaml

from .config_tools import (
    SETTINGS_GROUP,
    read_gis_data_home,
    read_repository_settings,
)
from .context_managers import QgisStepManager, qgis_group_settings
from .path_tools import (
    is_absolute_file_path,
    is_absolute_folder_path,
    sha1sum,
)
from .qgis_log import log_message


BLOCKSIZE = 65536
GISDATAHOME_PREFIX_RE = re.compile(r'^:gisdatahome:(\/)*')
PROFILE_PREFIX_RE = re.compile(r'^:profile:(\/)*')


DownloadableFile = namedtuple(
    'DownloadableFile',
    (
        'name',
        'version',
        'sha1sum',
        'dest_folder',
        'whats_new',
    )
)


class DownloadSharedFilesAlgorithm(QgisAlgorithm):
    """QGIS Processing algorithm to download shared files from a web
    repository."""

    REPO_TITLE = 'REPO_TITLE'
    OUTPUT_HTML_FILE = 'OUTPUT_HTML_FILE'

    def name(self):
        """Algorithm identifier."""
        return 'downloadsharedfiles'

    def displayName(self):
        """Algorithm human name."""
        return self.tr('Download shared files')

    def groupId(self):
        """Algorithm group identifier."""
        return 'filetools'

    def group(self):
        """Algorithm group human name."""
        return self.tr('File tools')

    def shortHelpString(self):
        """Algorithm help message displayed in the right panel."""
        return self.tr(
            "This algorithm downloads GIS shared files from given web "
            "repository. Only files that have been added or updated on the "
            "repository are downloaded. Existing files will replaced by the "
            "new version on local hard drive.\n\n"
            "After successful download, an HTML report is generated showing "
            "what files have been downloaded."
        )

    def icon(self):
        """Algorithm's icon."""
        return QIcon(':/plugins/download_shared_files/'
                     'download_shared_files.png')

    def initAlgorithm(self, config):
        """Initialize algorithm with inputs and output parameters."""
        self.gis_data_home = read_gis_data_home()
        with qgis_group_settings(SETTINGS_GROUP) as s:
            self.repo_titles = s.childGroups()
            if not self.repo_titles:
                log_message(self.tr('No repository configured'),
                            level='Warning', duration=5)
        self.addParameter(
            QgsProcessingParameterEnum(
                self.REPO_TITLE,
                self.tr('Repository'),
                options=self.repo_titles,
            )
        )
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT_HTML_FILE,
                self.tr('Download report'),
                self.tr('HTML files (*.html)'),
                None,
                True)
        )
        self.version = None

    def processAlgorithm(self, parameters, context, feedback):
        """Actual processing steps."""
        if not self.gis_data_home:
            raise QgsProcessingException(self.tr(
                'gis_data_home not found. You have to set gis_data_home '
                'global variable to the path of your main GIS folder (in '
                'Preferences -> Settings dialog, Variables tab).'
            ))
        repo_idx = self.parameterAsEnum(parameters, self.REPO_TITLE, context)
        repo_title = self.repo_titles[repo_idx]
        repo_settings = read_repository_settings(repo_title)
        repo_url = repo_settings.url
        output_file = self.parameterAsFileOutput(parameters,
                                                 self.OUTPUT_HTML_FILE,
                                                 context)
        files_to_download = [
            downloadable_file
            for downloadable_file in self._downloadable_files(repo_url)
            if self._is_file_to_download(downloadable_file, feedback)
        ]
        step_count = len(files_to_download)
        multi_feedback = QgsProcessingMultiStepFeedback(step_count, feedback)
        self.run_next_step = QgisStepManager(
            multi_feedback,
            abort_message=self.tr('Aborting on user request')
        )
        # Download each file
        outputs = dict()
        results = dict()
        for i, downloadable_file in enumerate(files_to_download):
            dest_folder = self._resolve_dest_folder(downloadable_file)
            if not is_absolute_folder_path(dest_folder):
                dest_folder.mkdir(mode=0o755)
            file_name = downloadable_file.name
            file_path = dest_folder / file_name
            version_file_path = dest_folder / '{}.ver'.format(file_name)
            with self.run_next_step:
                multi_feedback.pushConsoleInfo(self.tr(
                    'Downloading file {}...'.format(file_name)
                ))
                alg_params = {
                    'URL': urljoin(repo_url, file_name),
                    'OUTPUT': file_path.as_posix(),
                }
                try:
                    outputs[file_name] = run_alg(
                        'native:filedownloader',
                        alg_params,
                        context=context,
                        feedback=multi_feedback,
                        is_child_algorithm=True
                    )
                except QgsProcessingException:
                    feedback.reportError(self.tr(
                        'Unable to download file '
                        '{fname}'.format(fname=file_name)
                    ))
                    continue
                multi_feedback.pushConsoleInfo(self.tr(
                    'Download complete for file {}. Now checking file '
                    'integrity'.format(file_name)
                ))
                if sha1sum(file_path, BLOCKSIZE) != downloadable_file.sha1sum:
                    raise QgsProcessingException(self.tr(
                        'SHA1 checksum of downloaded file does not match '
                        'expected one. Something went wrong during download '
                        'of file {}. Please try again.'.format(file_name)
                    ))
                with version_file_path.open('w', encoding='UTF-8') as f:
                    f.write(str(downloadable_file.version))
                multi_feedback.pushConsoleInfo(self.tr(
                    'File {} sucessfully downloaded.'.format(file_name)
                ))
                multi_feedback.setProgressText(self.tr(
                    'File {i} of {count} successfully '
                    'downloaded.'.format(i=i, count=step_count)
                ))
                results[file_name] = outputs[file_name]['OUTPUT']
        if self.version:
            with qgis_group_settings(SETTINGS_GROUP) as s:
                s.setValue('{}/files_version'.format(repo_title), self.version)
        if output_file:
            self._create_download_report(output_file, files_to_download)
            results[self.OUTPUT_HTML_FILE] = output_file
        return results

    def _create_download_report(self, output_html_path, downloaded_files):
        """Create the given HTML file which a report of what file were
        downloaded."""
        ts = datetime.now()
        generated_date = ts.strftime('%a %d %b %Y')
        generated_time = ts.strftime('%H h %M')
        if not downloaded_files:
            tmpl_content = self.tr('<p>All files are up-to-date. '
                                   'No files downloaded</p>')
        else:
            tmpl_content = (
                '<ul>\n'
                '{}\n'
                '</ul>\n'.format('\n'.join(
                    '<li>{}</li>'.format(
                        self.tr(
                            '<p>{fname} (version: {version})</p>\n'
                            '<p><strong>Release notes</strong>. '
                            '{new}</p>'.format(
                                fname=downloaded_file.name,
                                version=downloaded_file.version,
                                new=downloaded_file.whats_new,
                            )
                        )
                    )
                    for downloaded_file in downloaded_files
                ))
            )
        tmpl_path = pathlib.Path(__file__).parent / 'download_report.html'
        output_path = pathlib.Path(output_html_path)
        with tmpl_path.open(encoding='utf-8') as tmpl, \
                output_path.open('w', encoding='utf-8') as f:
            f.write(tmpl.read().format(
                report_title=self.tr('Download report'),
                section_title=self.tr('Downloaded files'),
                generated_date=generated_date,
                generated_time=generated_time,
                content=tmpl_content
            ))

    def _downloadable_files(self, repo_url):
        """Download ``files.yml`` from Ana repository and yield each file
        description found there as a ``DownloadbleFile`` instance."""
        with urlopen(urljoin(repo_url, 'files.yml')) as remote_f:
            d = load_yaml(remote_f.read(), Loader=SafeLoader)
            self.version = int(d['version'])
            downloadable_files = d['files']
        for downloadable_file in downloadable_files:
            yield DownloadableFile(**downloadable_file)

    def _is_file_to_download(self, downloadable_file, feedback):
        """Return ``True`` if the given ``DownloadableFile`` instance needs to
        be downloaded again."""
        dest_folder = self._resolve_dest_folder(downloadable_file)
        file_name = downloadable_file.name
        version_file_path = dest_folder / '{}.ver'.format(file_name)
        local_version = '0'
        if is_absolute_file_path(version_file_path):
            with version_file_path.open(encoding='utf-8') as f:
                try:
                    local_version = f.readline().strip()
                except Exception:
                    feedback.pushConsoleInfo(self.tr(
                        'Unable to read version file for {}. Download '
                        'it again.'.format(file_name)
                    ))
        if local_version >= str(downloadable_file.version):
            feedback.pushConsoleInfo(self.tr(
                'File {} up-to-date. Nothing to do.'.format(file_name)
            ))
            return False
        else:
            return True

    def _resolve_dest_folder(self, downloadable_file):
        """Return a ``Path`` object matching the ``dest`_folder`` attribute
        of the given ``DownloadableFile`` instance."""
        dest_folder = downloadable_file.dest_folder.strip()
        if dest_folder.startswith(':gisdatahome:'):
            p = self.gis_data_home / GISDATAHOME_PREFIX_RE.sub('', dest_folder)
        elif dest_folder.startswith(':profile:'):
            profile_path = pathlib.Path(QgsApplication.instance().
                                        qgisSettingsDirPath())
            p = profile_path / PROFILE_PREFIX_RE.sub('', dest_folder)
        else:  # Else, assume it is a path relative to gis_data_home
            p = pathlib.Path(dest_folder)
            if not p:
                raise QgsProcessingException(self.tr(
                    'dest_folder empty or not set for file {}.'.format(
                        downloadable_file.name
                    )
                ))
            if p.is_absolute():
                raise QgsProcessingException(self.tr(
                    'dest_folder cannot be an absolute path for {}.'.format(
                        downloadable_file.name
                    )
                ))
            p = self.gis_data_home / p
        return p
